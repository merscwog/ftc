#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     swerveMotor,   tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, PIDControl, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorTetrix, PIDControl, reversed, driveRight, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    leftServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    centerServo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_3,    rightServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    basketServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


// NOTE: 0.781 is 100.0 / 128.0
// NOTE: 0.594 is 76.0 / 128.0 (when using PID 76% is proper amount for AndyMark Motors)
short adjustValue(short inputValue)
{
    //inputValue = (short)((inputValue * (abs(inputValue) / 128.0)) * 0.781);
		//inputValue = (short)((inputValue * (abs(inputValue) / 128.0)) * 0.594);
		inputValue = (short)((inputValue * (abs(inputValue) * abs(inputValue)/ 16384.0)) * 0.594);
    if (abs(inputValue) < 15)
    {
    	inputValue = 0; // Don't move unless outside range
    }

    return inputValue;
}

// NOTE: 0 is considered opposite
bool oppositeSignsOrZeros(short one, short two) {
	if ((one > -10) && (one < 10)) {
		one = 0;
	}

	if ((two > -10) && (two < 10)) {
		two = 0;
	}

	return (((one <= 0) && (two >= 0)) ||
	        ((one >= 0) && (two <= 0)));
}

// NOTE: What is safe swerve motor CCW and CW values?
//       Also, how the heck is "swapped" going to work... yikes.
//       CCW is a positive value.
short normalizeSwerveMotor(short leftMotorSwerve, short rightMotorSwerve, short swerveEncoder, bool forwardIsFlipped)
{
	// NOTE: Just trying without swerve at all
	return 0;

	short safeLeft = 400;
	short safeRight = -400;

	if (oppositeSignsOrZeros(leftMotorSwerve, rightMotorSwerve)) {
		return 0;
	}

	short absLeft = leftMotorSwerve;
	short absRight = rightMotorSwerve;

	if (abs(absLeft - absRight) > 40) {
		return 0;
	}

	short actual = leftMotorSwerve;
	if (absRight > absLeft) {
		actual = rightMotorSwerve;
	}

	if (actual < 0) {
		actual = 5;
	}
	else {
		actual = -5;
	}

	// NOTE: Can only turn if moving away from danger zone.
	if (((swerveEncoder >= safeLeft) && (actual > 0)) ||
		  ((swerveEncoder <= safeRight) && (actual < 0))) {
		playSound(soundShortBlip);
		return 0;
	}

	return actual;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  bool forwardIsFlipped = false;
	bool button3StillPressed = false;

	bool basketShouldBeDown = false;
	bool button7StillPressed = false;

	bool leftCatcherActive = false;
	bool button9StillPressed = false;

	bool rightCatcherActive = false;
	bool button10StillPressed = false;

  while (true)
  {
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////
	  ////                                                   ////
	  ////      Add your robot specific tele-op code here.   ////
	  ////                                                   ////
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////

    // Insert code to have servos and motors respond to joystick and button values.

    // Look in the ROBOTC samples folder for programs that may be similar to what you want to perform.
    // You may be able to find "snippets" of code that are similar to the functions that you want to
    // perform.
    getJoystickSettings(joystick);

    short leftMotorSpeed = joystick.joy1_y1;
    short rightMotorSpeed = joystick.joy1_y2;

    short leftMotorSwerve = joystick.joy1_x1;
    short rightMotorSwerve = joystick.joy1_x2;

    bool button3BeingPressed = (bool)joy1Btn(3);

    if (button3BeingPressed && !button3StillPressed)
    {
    	forwardIsFlipped = !forwardIsFlipped;
    	button3StillPressed = true;
    }
    else if (! button3BeingPressed) {
    	button3StillPressed = false;
    }

    if (forwardIsFlipped) {
    	short newLeft = rightMotorSpeed * -1;
    	short newRight = leftMotorSpeed * -1;
    	//short newLeftSwerve = leftMotorSwerve * -1;
    	//short newRightSwerve = rightMotorSwerve * -1;

    	leftMotorSpeed = newLeft;
    	rightMotorSpeed = newRight;
    	//leftMotorSwerve = newLeftSwerve;
    	//rightMotorSwerve = newRightSwerve;
    }

    if (joy1Btn(Btn5)) {
    	short straightSpeed = leftMotorSpeed;
    	bool adjustToStraight = true;

    	// If both positive, use higher value
    	// If both negative, use lower value
    	if ((leftMotorSpeed > 0) && (rightMotorSpeed > 0)) {
    		if (rightMotorSpeed > straightSpeed) {
    			straightSpeed = rightMotorSpeed;
    		}
    	}
    	else if ((leftMotorSpeed < 0) && (rightMotorSpeed < 0)) {
    		if (rightMotorSpeed < straightSpeed) {
    			straightSpeed = rightMotorSpeed;
    		}
    	}
    	else {
    		adjustToStraight = false;
    	}

    	// If we should adjust to straight speed, set both to same value
    	if (adjustToStraight) {
    		leftMotorSpeed = straightSpeed;
    		rightMotorSpeed = straightSpeed;
    	}
    }

    motor[leftMotor]  = adjustValue(leftMotorSpeed);
    motor[rightMotor] = adjustValue(rightMotorSpeed);

    // NOTE: Determine joystick directions
    //short joysticksDirections = determineJoysticksDirection(

    short swerveEncoder = nMotorEncoder[swerveMotor];
    short normalizedSwerveMotor = normalizeSwerveMotor(leftMotorSwerve, rightMotorSwerve, swerveEncoder, forwardIsFlipped);

    bool robotMovingEnough = false;

    if ((abs(leftMotorSpeed) > 25) ||
    	  (abs(rightMotorSpeed) > 25)) {
   		robotMovingEnough = true;
   	}

    if (robotMovingEnough) {
    	//motor[swerveMotor] = normalizedSwerveMotor;
    	motor[swerveMotor] = 0;
    }
    else {
    	motor[swerveMotor] = 0;
    }

    //  This is lift specific code.
    if (joy1Btn(1)) {
    	nMotorEncoder[Lift] = 0;
    }

    bool manualLift = true;

    // Raise and lower lift.
    if (joy2Btn(4)) {
    	motor[Lift] = 35;
    }
    else if (joy2Btn(2)) {
   		motor[Lift] = -25;
    }
    else {
    	manualLift = false;
    }

    // Halt lift if neither auto action or manual action happening
  	if (!manualLift) {
  		motor[Lift] = 0;
		}

//		// Intake motors
//		if (joy2Btn(1)) {
//			motor[motorB] = 50;
// 			motor[motorC] = 50;
//		}
//		else {
//			motor[motorB] = 0;
//  		motor[motorC] = 0;
//		}

		if (joy1Btn(5)) {
			servo[centerServo] = 0;
		}
		else if (joy1Btn(6)) {
			servo[centerServo] = 255;
		}
		else {
			servo[centerServo] = 127;
		}

    bool button7BeingPressed = (bool)joy2Btn(7);

    if (button7BeingPressed && !button7StillPressed)
    {
    	basketShouldBeDown = !basketShouldBeDown;
    	button7StillPressed = true;
    }
    else if (! button7BeingPressed) {
    	button7StillPressed = false;
    }

		// NOTE: 135 is good "up" position
		//       246/247 is the "down" position
		//       Should be made into a toggle switch
		if (basketShouldBeDown) {
			servo[basketServo] = 246;
			motor[motorB] = 100;
  		motor[motorC] = 100;
		}
		else {
			if (joy2Btn(8)) {
				servo[basketServo] = 246;
			}
			else {
				servo[basketServo] = 135;
			}
			motor[motorB] = 0;
  		motor[motorC] = 0;
		}

		// NOTE: This should really be factored into some sort of function if possible
		//       ToggleButton would be awesome as an object class
		bool button9BeingPressed = (bool)joy2Btn(9);

    if (button9BeingPressed && !button9StillPressed)
    {
    	leftCatcherActive = !leftCatcherActive;
    	button9StillPressed = true;
    }
    else if (! button9BeingPressed) {
    	button9StillPressed = false;
    }

		if (leftCatcherActive) {
			//servo[leftServo] = 14;
			servo[leftServo] = 0;
		}
		else {
			servo[leftServo] = 124;
		}

		// NOTE: Right rolling goal capture
		bool button10BeingPressed = (bool)joy2Btn(10);

    if (button10BeingPressed && !button10StillPressed)
    {
    	rightCatcherActive = !rightCatcherActive;
    	button10StillPressed = true;
    }
    else if (! button10BeingPressed) {
    	button10StillPressed = false;
    }

		if (rightCatcherActive) {
			servo[rightServo] = 255;
			//servo[rightServo] = 237;
		}
		else {
			servo[rightServo] = 131;
		}
	}
}
