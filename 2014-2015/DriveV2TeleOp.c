#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     swerveMotor,   tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, PIDControl, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorTetrix, PIDControl, reversed, driveRight, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    leftServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    centerServo,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_3,    rightServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    basketServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


// NOTE: 0.781 is 100.0 / 128.0
// NOTE: 0.594 is 76.0 / 128.0 (when using PID 76% is proper amount for AndyMark Motors)
short adjustThrottleValue(short inputValue)
{
    //inputValue = (short)((inputValue * (abs(inputValue) / 128.0)) * 0.781);
		//inputValue = (short)((inputValue * (abs(inputValue) / 128.0)) * 0.594);
		inputValue = (short)((inputValue * (abs(inputValue) * abs(inputValue)/ 16384.0)) * 0.594);
    if (abs(inputValue) < 15)
    {
    	inputValue = 0; // Don't move unless outside range
    }
    else if (inputValue > 15)
    {
    	inputValue -= 14;
    }
    else if (inputValue < -15)
    {
    	inputValue += 14;
    }

    // NOTE: Knock down absolute speed allowed
    return inputValue;
}

short adjustTurnValue(short inputValue, bool goingForward) {
	short returnVal = 0;

	if (inputValue > 15) {
		returnVal = -10;
	}
	else if (inputValue < -15) {
		returnVal = 10;
	}

	if (!goingForward) {
		returnVal *= -1;
	}

	return returnVal;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  bool forwardIsFlipped = false;
	bool button3StillPressed = false;

	bool basketShouldBeDown = false;
	bool button7StillPressed = false;

	bool leftCatcherActive = false;
	bool button9StillPressed = false;

	bool rightCatcherActive = false;
	bool button10StillPressed = false;

  while (true)
  {
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////
	  ////                                                   ////
	  ////      Add your robot specific tele-op code here.   ////
	  ////                                                   ////
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////

    // Insert code to have servos and motors respond to joystick and button values.

    // Look in the ROBOTC samples folder for programs that may be similar to what you want to perform.
    // You may be able to find "snippets" of code that are similar to the functions that you want to
    // perform.
    getJoystickSettings(joystick);

    short throttleSpeed = joystick.joy1_y1;
    short turnDirection = joystick.joy1_x2;

    bool button3BeingPressed = (bool)joy1Btn(3);

    if (button3BeingPressed && !button3StillPressed)
    {
    	forwardIsFlipped = !forwardIsFlipped;
    	button3StillPressed = true;
    }
    else if (! button3BeingPressed) {
    	button3StillPressed = false;
    }

    if (forwardIsFlipped) {
    	throttleSpeed *= -1;
    	// Turn actually stays the same
    	//turnDirection *= -1;
    }

   	short motorSpeed = adjustThrottleValue(throttleSpeed);

   	if (joystick.joy1_TopHat == -1) {
   		motor[leftMotor]  = motorSpeed;
    	motor[rightMotor] = motorSpeed;

    	bool isMovingForward = true;
    	if (((motorSpeed > 0) && forwardIsFlipped) ||
    		  ((motorSpeed < 0) && !forwardIsFlipped)) {
    		isMovingForward = false;
    	}

    	//if (abs(motorSpeed) > 15) {
    	if (true) {
	   	 short turnSpeed = adjustTurnValue(turnDirection, isMovingForward);
	   	 motor[swerveMotor] = turnSpeed;
    	}
    	else {
    		motor[swerveMotor] = 0;
    	}
    }
    else if (joystick.joy1_TopHat == 2) {
    	motor[leftMotor] = 30;
    	motor[rightMotor] = -30;
    }
    else if (joystick.joy1_TopHat == 6) {
    	motor[leftMotor] = -30;
    	motor[rightMotor] = 30;
    }

    //  This is lift specific code.
    if (joy1Btn(1)) {
    	nMotorEncoder[Lift] = 0;
    }

    bool manualLift = true;

    // Raise and lower lift.
    if (joy2Btn(4)) {
    	motor[Lift] = 35;
    }
    else if (joy2Btn(2)) {
   		motor[Lift] = -25;
    }
    else {
    	manualLift = false;
    }

    // Halt lift if neither auto action or manual action happening
  	if (!manualLift) {
  		motor[Lift] = 0;
		}

//		// Intake motors
//		if (joy2Btn(1)) {
//			motor[motorB] = 50;
// 			motor[motorC] = 50;
//		}
//		else {
//			motor[motorB] = 0;
//  		motor[motorC] = 0;
//		}

		if (joy1Btn(5)) {
			servo[centerServo] = 0;
		}
		else if (joy1Btn(6)) {
			servo[centerServo] = 255;
		}
		else {
			servo[centerServo] = 127;
		}

    bool button7BeingPressed = (bool)joy2Btn(7);

    if (button7BeingPressed && !button7StillPressed)
    {
    	basketShouldBeDown = !basketShouldBeDown;
    	button7StillPressed = true;
    }
    else if (! button7BeingPressed) {
    	button7StillPressed = false;
    }

		// NOTE: 135 is good "up" position
		//       246/247 is the "down" position
		//       Should be made into a toggle switch
		if (basketShouldBeDown) {
			servo[basketServo] = 246;
			motor[motorB] = 100;
  		motor[motorC] = 100;
		}
		else {
			if (joy2Btn(8)) {
				servo[basketServo] = 246;
			}
			else {
				servo[basketServo] = 135;
			}
			motor[motorB] = 0;
  		motor[motorC] = 0;
		}

		// NOTE: This should really be factored into some sort of function if possible
		//       ToggleButton would be awesome as an object class
		bool button9BeingPressed = (bool)joy2Btn(9);

    if (button9BeingPressed && !button9StillPressed)
    {
    	leftCatcherActive = !leftCatcherActive;
    	button9StillPressed = true;
    }
    else if (! button9BeingPressed) {
    	button9StillPressed = false;
    }

		if (leftCatcherActive) {
			//servo[leftServo] = 14;
			servo[leftServo] = 0;
		}
		else {
			servo[leftServo] = 124;
		}

		// NOTE: Right rolling goal capture
		bool button10BeingPressed = (bool)joy2Btn(10);

    if (button10BeingPressed && !button10StillPressed)
    {
    	rightCatcherActive = !rightCatcherActive;
    	button10StillPressed = true;
    }
    else if (! button10BeingPressed) {
    	button10StillPressed = false;
    }

		if (rightCatcherActive) {
			servo[rightServo] = 255;
			//servo[rightServo] = 237;
		}
		else {
			servo[rightServo] = 131;
		}
	}
}
