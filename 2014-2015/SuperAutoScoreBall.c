#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S4,     irseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, PIDControl, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorTetrix, PIDControl, reversed, driveRight, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    leftServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    centerServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    rightServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    basketServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// NOTE: Wheels are 4" in diameter, times pi gives ~12.566" per rotation.
//       AndyMark motors are 280 CPR, or 1120 PPR (seen by nMotorEncoder[x])
//       Tetrix motors are 360 CPR, or 1440 PPR
//
//       12.566 in/rotation  1120 clicks/rotation  ~89 clicks/in

short inchesAsClicks(short inches)
{
	return (inches * 89);
}

task main()
{
  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.

  servo[basketServo] = 135;

  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
  ////                                                   ////
  ////    Add your robot specific autonomous code here.  ////
  ////                                                   ////
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////

  short val1 = -1;
  short val2 = -1;
  short val3 = -1;
  short val4 = -1;
  short val5 = -1;
  short val6 = -1;
  short val7 = -1;

  while (true) {
  	servo[centerServo] = 250;
  	wait1Msec(1000);
  	val1 = SensorValue[irseeker];
  	servo[centerServo] = 219;
  	wait1Msec(500);
  	val2 = SensorValue[irseeker];
  	servo[centerServo] = 187;
  	wait1Msec(500);
  	val3 = SensorValue[irseeker];
  	servo[centerServo] = 156;
  	wait1Msec(500);
  	val4 = SensorValue[irseeker];
  	servo[centerServo] = 124;
  	wait1Msec(500);
  	val5 = SensorValue[irseeker];
  	servo[centerServo] = 93;
  	wait1Msec(500);
  	val6 = SensorValue[irseeker];
  	servo[centerServo] = 61;
  	wait1Msec(500);
  	val7 = SensorValue[irseeker];
  	break;
	}

	short position = -1;
	short sum = val2 + val4 + val7;
	switch (sum) {
		case 16:
			position = 1;
			break;
		case 17:
			position = 2;
			break;
		case 21:
		  position = 3;
		  break;
		default:
		  position = 0;
		  break;
	}

	/**
	while (true) {
		nxtDisplayBigStringAt(0, 61, "%d %d %d %d", val1, val2, val3, val4);
		nxtDisplayBigStringAt(0, 41, "%d %d %d", val5, val6, val7);
		nxtDisplayBigStringAt(0, 21, "%d", position);
  }
  **/

  if (position == 2) {
  	nMotorEncoder[leftMotor] = 0;
	  nMotorEncoder[rightMotor] = 0;

    short rotationDistance = inchesAsClicks(1.85);
    while (nMotorEncoder[rightMotor] < rotationDistance) {
  	  motor[leftMotor] = 0;
  	  motor[rightMotor] = 30;
    }
  }

	nMotorEncoder[leftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;

  motor[leftMotor] = 0;
  motor[rightMotor] = 0;

  // FIXME: Don't do anything
	if (position == 1)
	{
    short kickstandDistance = inchesAsClicks(63);
    while (nMotorEncoder[leftMotor] < kickstandDistance) {
  	  motor[leftMotor] = 50;
  	  motor[rightMotor] = 35;
    }

    nMotorEncoder[leftMotor] = 0;
    nMotorEncoder[rightMotor] = 0;

    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

    kickstandDistance = inchesAsClicks(20);
    while (nMotorEncoder[rightMotor] < kickstandDistance) {
  	  motor[leftMotor] = -30;
  	  motor[rightMotor] = 30;
    }

    nMotorEncoder[leftMotor] = 0;
    nMotorEncoder[rightMotor] = 0;

    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

    kickstandDistance = inchesAsClicks(18);
    while (nMotorEncoder[rightMotor] < kickstandDistance) {
  	  //motor[leftMotor] = 15;
  	  //motor[rightMotor] = 22;
  	  motor[leftMotor] = 70;
  	  motor[rightMotor] = 100;
    }

    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

  	wait1Msec(1000);
  	motor[motorB] = -100;
  	motor[motorC] = -100;
  	wait1Msec(1000);
    servo[basketServo] = 246;
    wait1Msec(3000);

    return;
  }

  nMotorEncoder[leftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;

  short goDistance = inchesAsClicks(30);
  while (nMotorEncoder[leftMotor] < goDistance) {
  	motor[leftMotor] = 30;
  	motor[rightMotor] = 30;
  }
  motor[leftMotor] = 0;
  motor[rightMotor] = 0;

  nMotorEncoder[Lift] = 0;

  while (nMotorEncoder[Lift] < 5000) {
  	motor[Lift] = 35;
  }
  while (nMotorEncoder[Lift] < 6500) {
  	motor[Lift] = 25;
  }
  while (nMotorEncoder[Lift] < 7000) {
  	motor[Lift] = 15;
  }

  // 7000 is about the exact height we need
  //wait1Msec(5375);
  motor[Lift] = 0;

  nMotorEncoder[leftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;

  goDistance = inchesAsClicks(7.5);
  while (nMotorEncoder[leftMotor] < goDistance) {
  	motor[leftMotor] = 20;
  	motor[rightMotor] = 20;
  }

  motor[leftMotor] = 0;
  motor[rightMotor] = 0;

  servo[basketServo] = 246;
  wait1Msec(1000);
  servo[basketServo] = 135;

  nMotorEncoder[leftMotor] = 0;
  nMotorEncoder[rightMotor] = 0;

  goDistance = inchesAsClicks(-7.5);
  while (nMotorEncoder[leftMotor] > goDistance) {
  	motor[leftMotor] = -20;
  	motor[rightMotor] = -20;
  }

  motor[leftMotor] = -100;
  motor[rightMotor] = -100;
  wait1Msec(250);

  motor[leftMotor] = 0;
  motor[rightMotor] = 0;

  while (nMotorEncoder[Lift] > 1000) {
  	motor[Lift] = -35;
  }
  while (nMotorEncoder[Lift] > 500) {
  	motor[Lift] = -25;
  }
  while (nMotorEncoder[Lift] > 0) {
  	motor[Lift] = -15;
  }

  motor[Lift] = 0;
}
